# Some Common Instructions to Remember

- **NOP** : It translates to `xchg eax eax` which has no effect on the register (`0x90`)
- **PUSH/POP** : Adds to the stack, Removes from the stack. esp decremented on a push and incremented on a pop
- **LEAVE** : Takes the esp and moves it to ebp. ebp is at the top of the stack frame.
- **CALL/RET** : RET assumes that whatever is on top of the stack, pops the instruction on top of the stack and sets the instruction pointer to it. CALL instructions push the address of next instruction on the stack
- **MOV/LEA** : Moves the value from a register to another register. LEA, loads the address of a value.
- **ADD/SUB** : Adds and stores to the register : `eax = eax + eax`
- **JMP/Jcc** : JMP unconditional jump, jcc is jump if condition is met
- **CMP/TEST** :CMP subtracts second from the first value. TEST does logical AND instruction
- **AND/OR/XOR/NOT** : standard logical operation
- **SHR/SHL/SAR/SAL** : SHR is the logical right shift, SAR is the logical right shift and so on

**Example**  :

- Let eax = 1100
- After two logical shifts

```
SHL 2

1000
0000
```

- The same is for an arithmetic left shift

```
SAL 2
1000
0000
```

- Let eax = 1100
- Perform logical right shifts

```
SHR 2

0110
0011
```

- Performing with signed numbers 
- That means 1100 is -4
- While shifting arithmetic right by 1.

```
SAR 1

1110
```

- Because we put 1 for the most significant bit



- **IMUL/DIV** : IMUL is a signed multiply. It is the only x86 instruction that takes 3 arguments.
- **REP STOS, REP MOVS** : `REP STOS` repeats stored strings. `ecx` holds the count of how many times you want to do the operation

**REP STOS**

```
REP STOS

ECX = count
```

- Everytime the instruction is executed the value of ecx is decreased and runs until ecx=0

**REP MOVS**

- The value is stored to the destination

```
REP STOS

ECX = count

EDI = Destination
```

- ESI -> Source EDI -> Destination
- This instruction is mostly used in memcpy


- **LEAVE** : MOV EBP to ESP ; POP EBP